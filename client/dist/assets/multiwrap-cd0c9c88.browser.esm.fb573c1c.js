import{C,_ as n,a as g,ac as T,u as m,T as u,A as y,c as I,ad as E,d as $,e as b,k as R,G as S,i as P,f as q,n as F,V as M,X as x,x as L,M as A}from"./index.8d0b9aaf.js";import{S as O}from"./erc-721-standard-b90faf4d.browser.esm.10f70563.js";import{h as U}from"./hasERC20Allowance-59b9da80.browser.esm.32686005.js";class l extends O{constructor(a,e,s){let o=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{},t=arguments.length>4?arguments[4]:void 0,r=arguments.length>5?arguments[5]:void 0,c=arguments.length>6&&arguments[6]!==void 0?arguments[6]:new C(a,e,t,o);super(c,s,r),n(this,"abi",void 0),n(this,"encoder",void 0),n(this,"estimator",void 0),n(this,"metadata",void 0),n(this,"app",void 0),n(this,"events",void 0),n(this,"roles",void 0),n(this,"royalties",void 0),n(this,"owner",void 0),n(this,"wrap",g(async(h,i,d)=>{const f=await T(i,this.storage),W=await m(d||await this.contractWrapper.getSignerAddress()),v=await this.toTokenStructList(h);return u.fromContractWrapper({contractWrapper:this.contractWrapper,method:"wrap",args:[v,f,W],parse:p=>{const w=this.contractWrapper.parseLogs("TokensWrapped",p==null?void 0:p.logs);if(w.length===0)throw new Error("TokensWrapped event not found");const k=w[0].args.tokenIdOfWrappedToken;return{id:k,receipt:p,data:()=>this.get(k)}}})})),n(this,"unwrap",g(async(h,i)=>{const d=await m(i||await this.contractWrapper.getSignerAddress());return u.fromContractWrapper({contractWrapper:this.contractWrapper,method:"unwrap",args:[h,d]})})),this.abi=y.parse(t||[]),this.metadata=new I(this.contractWrapper,E,this.storage),this.app=new $(this.contractWrapper,this.metadata,this.storage),this.roles=new b(this.contractWrapper,l.contractRoles),this.encoder=new R(this.contractWrapper),this.estimator=new S(this.contractWrapper),this.events=new P(this.contractWrapper),this.royalties=new q(this.contractWrapper,this.metadata),this.owner=new F(this.contractWrapper)}async getWrappedContents(a){const e=await this.contractWrapper.readContract.getWrappedContents(a),s=[],o=[],t=[];for(const r of e)switch(r.tokenType){case 0:{const c=await M(this.contractWrapper.getProvider(),r.assetContract);s.push({contractAddress:r.assetContract,quantity:x(r.totalAmount,c.decimals)});break}case 1:{o.push({contractAddress:r.assetContract,tokenId:r.tokenId});break}case 2:{t.push({contractAddress:r.assetContract,tokenId:r.tokenId,quantity:r.totalAmount.toString()});break}}return{erc20Tokens:s,erc721Tokens:o,erc1155Tokens:t}}async toTokenStructList(a){const e=[],s=this.contractWrapper.getProvider(),o=await this.contractWrapper.getSignerAddress();if(a.erc20Tokens)for(const t of a.erc20Tokens){const r=await L(s,t.quantity,t.contractAddress);if(!await U(this.contractWrapper,t.contractAddress,r))throw new Error(`ERC20 token with contract address "${t.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${t.contractAddress}").setAllowance("${this.getAddress()}", ${t.quantity});

`);e.push({assetContract:t.contractAddress,totalAmount:r,tokenId:0,tokenType:0})}if(a.erc721Tokens)for(const t of a.erc721Tokens){if(!await A(this.contractWrapper.getProvider(),this.getAddress(),t.contractAddress,t.tokenId,o))throw new Error(`ERC721 token "${t.tokenId}" with contract address "${t.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${t.contractAddress}").setApprovalForToken("${this.getAddress()}", ${t.tokenId});

`);e.push({assetContract:t.contractAddress,totalAmount:0,tokenId:t.tokenId,tokenType:1})}if(a.erc1155Tokens)for(const t of a.erc1155Tokens){if(!await A(this.contractWrapper.getProvider(),this.getAddress(),t.contractAddress,t.tokenId,o))throw new Error(`ERC1155 token "${t.tokenId}" with contract address "${t.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${t.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);e.push({assetContract:t.contractAddress,totalAmount:t.quantity,tokenId:t.tokenId,tokenType:2})}return e}async prepare(a,e,s){return u.fromContractWrapper({contractWrapper:this.contractWrapper,method:a,args:e,overrides:s})}async call(a,e,s){return this.contractWrapper.call(a,e,s)}}n(l,"contractRoles",["admin","transfer","minter","unwrap","asset"]);export{l as Multiwrap};
