import {
  AbiSchema,
  AddressOrEnsSchema,
  AmountSchema,
  BigNumberSchema,
  BigNumberTransformSchema,
  BigNumberishSchema,
  CommonNFTInput,
  CommonNFTOutput,
  ContractPublisher,
  GENERATED_ABI,
  IThirdwebContract_default,
  NFTInputOrUriSchema,
  PREBUILT_CONTRACTS_MAP,
  SmartContract,
  ThirdwebStorage,
  computeDeploymentInfo,
  detectFeatures,
  extractFeatures,
  getCompositePluginABI,
  getContractTypeForRemoteName,
  getCreate2FactoryAddress,
  getInitBytecodeWithSalt,
  getSignerAndProvider,
  hasMatchingAbi,
  invariant,
  isContractDeployed,
  require_bs58,
  require_dist,
  require_fast_deep_equal,
  resolveAddress,
  z
} from "./chunk-PQHXTTPB.js";
import {
  require_browser_ponyfill
} from "./chunk-KSBPR6CT.js";
import {
  require_utils
} from "./chunk-XQLXTUOU.js";
import {
  Contract,
  ethers_exports,
  init_lib7 as init_lib,
  utils_exports
} from "./chunk-T4GQYX7O.js";
import {
  BigNumber
} from "./chunk-RGAYGF33.js";
import {
  require_bn
} from "./chunk-2O4376VB.js";
import {
  init_shim
} from "./chunk-ZGMFR26H.js";
import {
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/@thirdweb-dev/sdk/dist/abi-5f330c89.browser.esm.js
init_shim();
init_lib();
var PropertiesInput = z.object({}).catchall(z.union([BigNumberTransformSchema, z.unknown()]));
var OptionalPropertiesInput = z.union([z.array(PropertiesInput), PropertiesInput]).optional();
var TokenMintInputSchema = z.object({
  toAddress: AddressOrEnsSchema,
  amount: AmountSchema
});
var EditionMetadataOutputSchema = z.object({
  supply: BigNumberSchema,
  metadata: CommonNFTOutput
});
var EditionMetadataWithOwnerOutputSchema = EditionMetadataOutputSchema.extend({
  owner: z.string(),
  quantityOwned: BigNumberSchema
});
var EditionMetadataInputSchema = z.object({
  supply: BigNumberishSchema,
  metadata: CommonNFTInput
});
var EditionMetadataInputOrUriSchema = z.object({
  supply: BigNumberishSchema,
  metadata: NFTInputOrUriSchema
});
var ProposalState = function(ProposalState2) {
  ProposalState2[ProposalState2["Pending"] = 0] = "Pending";
  ProposalState2[ProposalState2["Active"] = 1] = "Active";
  ProposalState2[ProposalState2["Canceled"] = 2] = "Canceled";
  ProposalState2[ProposalState2["Defeated"] = 3] = "Defeated";
  ProposalState2[ProposalState2["Succeeded"] = 4] = "Succeeded";
  ProposalState2[ProposalState2["Queued"] = 5] = "Queued";
  ProposalState2[ProposalState2["Expired"] = 6] = "Expired";
  ProposalState2[ProposalState2["Executed"] = 7] = "Executed";
  return ProposalState2;
}({});
function matchesPrebuiltAbi(contractWrapper, abi) {
  return hasMatchingAbi(AbiSchema.parse(contractWrapper.abi || []), [abi]);
}
function getAllDetectedFeatures(abi) {
  const features = [];
  extractFeatures(detectFeatures(abi), features);
  return features;
}
function getAllDetectedExtensions(abi) {
  return getAllDetectedFeatures(abi).map((f) => ({
    ...f,
    extensions: f.features
  }));
}
async function normalizeAmount(contractWrapper, amount) {
  const decimals = await contractWrapper.readContract.decimals();
  return utils_exports.parseUnits(AmountSchema.parse(amount), decimals);
}
function toEther(amount) {
  return utils_exports.formatEther(amount);
}
function toUnits(amount, decimals) {
  return utils_exports.parseUnits(AmountSchema.parse(amount), decimals);
}
function toDisplayValue(amount, decimals) {
  return utils_exports.formatUnits(amount, decimals);
}
async function computeNativeTokenAddress(provider, storage, create2Factory) {
  if (!create2Factory) {
    create2Factory = await getCreate2FactoryAddress(provider);
  }
  return (await computeDeploymentInfo("infra", provider, storage, create2Factory, {
    contractName: "WETH9"
  })).transaction.predictedAddress;
}
async function deployContractDeterministicRaw(signer, bytecode, encodedArgs, create2FactoryAddress, options, predictedAddress) {
  let gasLimit = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 7e6;
  invariant(signer.provider, "Provider required");
  const contractDeployed = predictedAddress ? await isContractDeployed(predictedAddress, signer.provider) : false;
  if (!contractDeployed) {
    console.debug(`deploying contract via create2 factory at: ${predictedAddress}`);
    const initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, encodedArgs);
    let tx = {
      to: create2FactoryAddress,
      data: initBytecodeWithSalt
    };
    try {
      await signer.estimateGas(tx);
    } catch (e) {
      console.debug("error estimating gas while deploying prebuilt: ", e);
      tx.gasLimit = BigNumber.from(gasLimit);
    }
    await (await signer.sendTransaction(tx)).wait();
  }
}
function getCachedAbiForContract(address) {
  if (address in GENERATED_ABI) {
    return GENERATED_ABI[address];
  }
  return void 0;
}

// node_modules/@thirdweb-dev/sdk/dist/watchTransactions-dea1ed32.browser.esm.js
init_shim();
init_lib();
var STORAGE_CACHE = new ThirdwebStorage();
var CONTRACT_CACHE = /* @__PURE__ */ new Map();
function getContractCacheKey(address, chainId) {
  return `${address}-${chainId}`;
}
function inContractCache(address, chainId) {
  const cacheKey = getContractCacheKey(address, chainId);
  return CONTRACT_CACHE.has(cacheKey);
}
function getCachedContract(address, chainId) {
  if (!inContractCache(address, chainId)) {
    throw new Error(`Contract ${address} was not found in cache`);
  }
  const cacheKey = getContractCacheKey(address, chainId);
  return CONTRACT_CACHE.get(cacheKey);
}
function cacheContract(contract, address, chainId) {
  const cacheKey = getContractCacheKey(address, chainId);
  CONTRACT_CACHE.set(cacheKey, contract);
}
function getCachedStorage(storage) {
  return storage || STORAGE_CACHE;
}
async function getContractFromAbi(params) {
  const resolvedAddress = await resolveAddress(params.address);
  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  const chainId = (await provider.getNetwork()).chainId;
  if (inContractCache(resolvedAddress, chainId)) {
    return getCachedContract(resolvedAddress, chainId);
  }
  const parsedAbi = typeof params.abi === "string" ? JSON.parse(params.abi) : params.abi;
  const contract = new SmartContract(signer || provider, resolvedAddress, await getCompositePluginABI(resolvedAddress, AbiSchema.parse(parsedAbi), provider, params.sdkOptions, getCachedStorage(params.storage)), getCachedStorage(params.storage), params.sdkOptions, chainId);
  cacheContract(contract, resolvedAddress, chainId);
  return contract;
}
async function resolveContractType(params) {
  try {
    const contract = new Contract(params.address, IThirdwebContract_default, params.provider);
    const remoteContractType = ethers_exports.utils.toUtf8String(await contract.contractType()).replace(/\x00/g, "");
    return getContractTypeForRemoteName(remoteContractType);
  } catch (err) {
    return "custom";
  }
}
async function getContract(params) {
  const resolvedAddress = await resolveAddress(params.address);
  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  const chainId = (await provider.getNetwork()).chainId;
  if (inContractCache(resolvedAddress, chainId)) {
    return getCachedContract(resolvedAddress, chainId);
  }
  if (!params.contractTypeOrAbi || params.contractTypeOrAbi === "custom") {
    const contractType = await resolveContractType({
      address: resolvedAddress,
      provider
    });
    if (contractType === "custom") {
      const publisher = new ContractPublisher(params.network, params.sdkOptions, getCachedStorage(params.storage));
      try {
        const metadata = await publisher.fetchCompilerMetadataFromAddress(resolvedAddress);
        return getContractFromAbi({
          ...params,
          address: resolvedAddress,
          abi: metadata.abi
        });
      } catch {
        throw new Error(`No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${resolvedAddress}`);
      }
    } else {
      const abi = await PREBUILT_CONTRACTS_MAP[contractType].getAbi(resolvedAddress, provider, getCachedStorage(params.storage));
      return getContractFromAbi({
        ...params,
        address: resolvedAddress,
        abi
      });
    }
  } else if (typeof params.contractTypeOrAbi === "string" && params.contractTypeOrAbi in PREBUILT_CONTRACTS_MAP) {
    const contract = await PREBUILT_CONTRACTS_MAP[params.contractTypeOrAbi].initialize(signer || provider, resolvedAddress, getCachedStorage(params.storage), params.sdkOptions);
    cacheContract(contract, resolvedAddress, chainId);
    return contract;
  } else {
    return getContractFromAbi({
      ...params,
      address: resolvedAddress,
      abi: params.contractTypeOrAbi
    });
  }
}
var CHAIN_ID_CACHE = /* @__PURE__ */ new WeakMap();
async function getChainId(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  let chainIdPromise;
  if (CHAIN_ID_CACHE.has(provider)) {
    chainIdPromise = CHAIN_ID_CACHE.get(provider);
  } else {
    chainIdPromise = provider.getNetwork().then((network) => network.chainId).catch((err) => {
      CHAIN_ID_CACHE.delete(provider);
      throw err;
    });
    CHAIN_ID_CACHE.set(provider, chainIdPromise);
  }
  return await chainIdPromise;
}
async function getBlockNumber(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  return provider.getBlockNumber();
}
var BLOCK_PROMISE_CACHE = /* @__PURE__ */ new Map();
async function getBlock(params) {
  const chainId = await getChainId(params);
  const blockTag = params.block;
  const cacheKey = `${chainId}_${blockTag}`;
  let blockPromise;
  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {
    blockPromise = BLOCK_PROMISE_CACHE.get(cacheKey);
  } else {
    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
    blockPromise = provider.getBlock(blockTag).catch((err) => {
      BLOCK_PROMISE_CACHE.delete(cacheKey);
      throw err;
    });
    BLOCK_PROMISE_CACHE.set(cacheKey, blockPromise);
  }
  return await blockPromise;
}
var BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE = /* @__PURE__ */ new Map();
async function getBlockWithTransactions(params) {
  const chainId = await getChainId(params);
  const blockTag = params.block;
  const cacheKey = `${chainId}_${blockTag}`;
  let blockPromise;
  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {
    blockPromise = BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.get(cacheKey);
  } else {
    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
    blockPromise = provider.getBlockWithTransactions(blockTag).catch((err) => {
      BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.delete(cacheKey);
      throw err;
    });
    BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.set(cacheKey, blockPromise);
  }
  return await blockPromise;
}
function watchBlockNumber(params) {
  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);
  provider.on("block", params.onBlockNumber);
  return () => {
    provider.off("block", params.onBlockNumber);
  };
}
function watchBlock(_ref) {
  let {
    onBlock,
    ...sharedBlockParams
  } = _ref;
  async function onBlockNumber(blockNumber) {
    try {
      onBlock(await getBlock({
        block: blockNumber,
        ...sharedBlockParams
      }));
    } catch (err) {
    }
  }
  return watchBlockNumber({
    ...sharedBlockParams,
    onBlockNumber
  });
}
function watchBlockWithTransactions(_ref2) {
  let {
    onBlock,
    ...sharedBlockParams
  } = _ref2;
  async function onBlockNumber(blockNumber) {
    try {
      onBlock(await getBlockWithTransactions({
        block: blockNumber,
        ...sharedBlockParams
      }));
    } catch (err) {
    }
  }
  return watchBlockNumber({
    ...sharedBlockParams,
    onBlockNumber
  });
}
function watchTransactions(_ref) {
  let {
    address,
    onTransactions,
    ...sharedBlockParams
  } = _ref;
  const lcAddress = address.toLowerCase();
  function onBlock(block) {
    const transactions = block.transactions.filter((tx) => {
      var _a;
      if (tx.from.toLowerCase() === lcAddress) {
        return true;
      }
      return ((_a = tx.to) == null ? void 0 : _a.toLowerCase()) === lcAddress;
    });
    if (transactions.length > 0) {
      onTransactions(transactions);
    }
  }
  return watchBlockWithTransactions({
    ...sharedBlockParams,
    onBlock
  });
}

// node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.browser.esm.js
init_shim();
var import_bn = __toESM(require_bn());
init_lib();
var import_cross_fetch = __toESM(require_browser_ponyfill());
var import_utils = __toESM(require_utils());
var import_merkletreejs = __toESM(require_dist());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var import_utils2 = __toESM(require_utils());
var import_bs58 = __toESM(require_bs58());
globalThis.global = globalThis;

// node_modules/@thirdweb-dev/wallets/dist/keys-bd983fca.browser.esm.js
init_shim();
var DEFAULT_WALLET_API_KEY = "4f20f63d3ce0ec88eca639a291effef1559289d5614d77040d783048a4b3f316";

export {
  OptionalPropertiesInput,
  TokenMintInputSchema,
  EditionMetadataOutputSchema,
  EditionMetadataWithOwnerOutputSchema,
  EditionMetadataInputSchema,
  EditionMetadataInputOrUriSchema,
  ProposalState,
  matchesPrebuiltAbi,
  getAllDetectedFeatures,
  getAllDetectedExtensions,
  normalizeAmount,
  toEther,
  toUnits,
  toDisplayValue,
  computeNativeTokenAddress,
  deployContractDeterministicRaw,
  getCachedAbiForContract,
  getContractFromAbi,
  getContract,
  getChainId,
  getBlockNumber,
  getBlock,
  getBlockWithTransactions,
  watchBlockNumber,
  watchBlock,
  watchBlockWithTransactions,
  watchTransactions,
  DEFAULT_WALLET_API_KEY
};
//# sourceMappingURL=chunk-NR6T4EIN.js.map
